#include <furi.h>
#include <furi_hal.h>
#include <furi_hal_bt.h>
#include <input/input.h>
#include <storage/storage.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <furi_hal_rtc.h>
#include <stdio.h>
// #include <time.h>

/* generated by fbt from .png files in images folder */
#include <bleash_icons.h>
#include <gui/canvas.h>
#include <gui/gui.h>
#include <gui/view_port.h>
#include <storage/filesystem_api_defines.h>

#define TAG                        "Bleash"
#define LOG_FOLDER_PATH            "/ext/Bleash"
#define LOG_FILE_PATH              "/ext/Bleash/bleash.log"
#define MAX_LOG_SIZE               1024
#define MAX_LOG_ENTRIES            1000
#define RSSI_THRESHOLD             -70 // dBm
#define POLL_INTERVAL_MS           1000 // ms
#define DEFAULT_BACKGROUND_RUNNING false

typedef enum {
    BleashStateIdle,
    BleashStateMonitoring,
    BleashStateConnected,
    BleashStateDisconnected,
    BleashStateError,
    BleashStateExit,
    BleashStateViewLogs,
} BleashState;

typedef enum {
    EventTypeStart,
    EventTypeStop,
    EventTypeToggleBackground,
    EventTypeExit,
} BleashEventType;

typedef struct {
    BleashEventType type;
} BleashEvent;

typedef enum {
    MenuStateIdle,
    MenuStateStart,
    MenuStateStop,
    MenuStateToggleBackground,
    MenuStateExit,
} MenuState;

typedef enum {
    MenuItemIdle,
    MenuItemStart,
    MenuItemStop,
    MenuItemToggleBackground,
    MenuItemExit,
} MenuItem;

typedef struct {
    FuriMessageQueue* event_queue;
    ViewPort* view_port;
    Gui* gui;
    Storage* storage;
    NotificationApp* notifications;
    FuriMutex* mutex;
    BleashState state;
    MenuItem selected_item;
    uint32_t sequence_counter;
    uint32_t sequence_source;
    bool background_running;
} Bleash;

// change log_event to open with correct flags
static void log_event(Bleash* b, int8_t rssi) {
    DateTime dt;
    furi_hal_rtc_get_datetime(&dt);
    char line[64];
    size_t len = snprintf(
        line,
        sizeof(line),
        "%04d-%02d-%02d %02d:%02d:%02d: RSSI %d\n",
        dt.year,
        dt.month,
        dt.day,
        dt.hour,
        dt.minute,
        dt.second,
        rssi);
    File* f = storage_file_alloc(b->storage);
    if(f && storage_file_open(f, LOG_FILE_PATH, FSAM_WRITE, FSOM_OPEN_ALWAYS | FSOM_OPEN_APPEND)) {
        storage_file_write(f, (uint8_t*)line, len);
        storage_file_close(f);
    }
    if(f) storage_file_free(f);
}

// draw the toggle state
static void draw_callback(Canvas* canvas, void* ctx) {
    Bleash* b = ctx;
    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str(canvas, 2, 12, "Background:");
    canvas_draw_str(canvas, 2, 28, b->background_running ? "ON" : "OFF");
    canvas_draw_str(canvas, 2, 50, "OK to toggle");
    canvas_draw_str(canvas, 2, 62, "Back to exit");
}

// handle key presses, enqueue a named local BleashEvent
static void input_callback(InputEvent* event, void* ctx) {
    Bleash* b = ctx;
    if(event->type == InputTypeShort) {
        if(event->key == InputKeyOk) {
            b->background_running = !b->background_running;
        } else if(event->key == InputKeyBack) {
            BleashEvent exit_msg = {.type = EventTypeExit};
            furi_message_queue_put(b->event_queue, &exit_msg, FuriWaitForever);
        }
    }
}

static bool bleash_init_storage(Bleash* app) {
    if(!storage_dir_exists(app->storage, LOG_FOLDER_PATH)) {
        FURI_LOG_I(TAG, "Creating log directory");
        if(!storage_common_mkdir(app->storage, LOG_FOLDER_PATH)) {
            FURI_LOG_E(TAG, "Failed to create log directory");
            return false;
        }
    }

    return true;
}

int32_t BLEASH(void* p) {
    UNUSED(p);
    Bleash b;
    b.storage = furi_record_open("storage");
    // ensure log directory exists
    if(!bleash_init_storage(&b)) {
        furi_record_close("storage");
        return 1;
    }
    b.background_running = DEFAULT_BACKGROUND_RUNNING; // set default

    // set up GUI
    b.event_queue = furi_message_queue_alloc(8, sizeof(BleashEvent));
    b.view_port = view_port_alloc();
    b.gui = furi_record_open("gui");
    view_port_draw_callback_set(b.view_port, draw_callback, &b);
    view_port_input_callback_set(b.view_port, input_callback, &b);
    gui_add_view_port(b.gui, b.view_port, GuiLayerFullscreen);

    // show toggle screen first
    furi_delay_ms(10); // let GUI settle

    // wait until user exits toggle screen
    BleashEvent ev;
    while(furi_message_queue_get(b.event_queue, &ev, FuriWaitForever) == FuriStatusOk) {
        if(ev.type == EventTypeExit) break;
    }

    // remove toggle GUI
    gui_remove_view_port(b.gui, b.view_port);
    view_port_free(b.view_port);
    furi_record_close("gui");

    // main monitoring loop
    while(1) {
        int8_t rssi = furi_hal_bt_get_rssi();
        if(rssi < RSSI_THRESHOLD) {
            furi_hal_vibro_on(true);
            log_event(&b, rssi);
        }
        furi_delay_ms(POLL_INTERVAL_MS);
        if(!b.background_running) {
            // if user turned off background, break or sleep until next run
        }
    }
    return 0;
}
